# 极致的抽象
为了避免后续代码继续腐化，我决定使用抽象的力量来解决

### 优化方案

- 解析器部分：使用策略模式，不同类型的解析策略独立维护(难点是不同解析策略的返回值不同)
- 文件保存部分：使用模板方法模式，统一保存流程(难点是不同保存方式的方法参数不同)
- SSE流式处理：抽象出通用的流式处理逻辑(目前每种生成模式都写了一套处理代码)

#### 策略模式

策略模式定义了一系列算法，将每个算法封装起来，并让它们可以相互替换，使得算法的变化不会影响使用算法的代码，让项目更好维护和扩展。

#### 模板方法模式

模板方法模式再抽象父类定义了操作的标准流程，将一些具体实现步骤交给子类，使得子类可以再不改变流程的情况下重新定义某些特定步骤。

#### 执行器模式

正常情况下，可以通过工厂模式来创建不同的策略或模板方法，但由于每种生成模式的参数和返回值不同(HtmlCodeResult和MultiFileCodeResult)，很难对通过工厂模式创建出来的对象进行统一的调用。

执行器模式提供统一的执行入口来协调不同策略和模板的调用，特别适合处理参数不同但业务逻辑类似的场景，避免了工厂模式在处理不同参数类型时的局限性。


#### 混合模式

最终，我们预期的代码架构是一种混合模式：
- 执行器模式：提供统一的执行入口，根据生成类型不同的操作
- 策略模式：每种模式对应的解析方法单独作为一个类来维护
- 模板方法模式：抽象模板定义了通用的文件保存流程，子类可以有自己的实现(比如多文件生成模式需要保存3个文件，而原生HTML模式只需要保存一个文件)